# SOF-ELKÂ® Configuration File
# (C)2024 Lewes Technology Consulting, LLC
#
# This file contains filters, transforms, and enrichments for Filesystem logs from the KAPE forensic tool

filter {
  if [type] == "kape_filesystem" {
    mutate {
      # create two "timestamp" fields with the MACBs in subfields
      # create a KAPE-specific bit field
      # promote the remaining fields of interest out of the [raw] placeholder
      # remove the [raw] placeholder

      # see https://binaryforay.blogspot.com/2018/06/introducing-mftecmd.html and
      # https://computerforensics.parsonage.co.uk/downloads/TheMeaningofLIFE.pdf
      rename => {
        "[raw][LastRecordChange0x10]" => "[file][stdinfo][ctime]"
        "[raw][LastModified0x10]" => "[file][stdinfo][mtime]"
        "[raw][LastAccess0x10]" => "[file][stdinfo][accessed]"
        "[raw][Created0x10]" => "[file][stdinfo][created]"

        "[raw][LastRecordChange0x30]" => "[file][filename][ctime]"
        "[raw][LastModified0x30]" => "[file][filename][mtime]"
        "[raw][LastAccess0x30]" => "[file][filename][accessed]"
        "[raw][Created0x30]" => "[file][filename][created]"

        "[raw][InUse]" => "[kape][mft][inuse]"
        "[raw][HasAds]" => "[kape][mft][hasads]"
        "[raw][IsAds]" => "[kape][mft][isads]"
        "[raw][Timestomped]" => "[kape][mft][timestomped]"
        "[raw][Copied]" => "[kape][mft][copied]"
        "[raw][NameType]" => "[kape][mft][name_type]"

        "[raw][SiFlags]" => "[file][attributes]"
        "[raw][EntryNumber]" => "[file][inode]"
        "[raw][SequenceNumber]" => "[file][sequence_number]"
        "[raw][ParentEntryNumber]" => "[file][parent][inode]"
        "[raw][ParentSequenceNumber]" => "[file][parent][sequence_number]"
        "[raw][ParentPath]" => "[file][directory]"
        "[raw][FileName]" => "[file][name]"
        "[raw][Extension]" => "[file][extension]"
        "[raw][FileSize]" => "[file][size]"
        "[raw][ReferenceCount]" => "[file][reference_count]"
        "[raw][ReparseTarget]" => "[file][reparse][target]"
        "[raw][UpdateSequenceNumber]" => "[file][update_sequence_number]"
        "[raw][LogfileSequenceNumber]" => "[file][logfile][sequence_number]"
        "[raw][SecurityId]" => "[file][uid]"
        "[raw][ObjectIdFileDroid]" => "[file][object_id]"
        "[raw][LoggedUtilStream]" => "[file][stream_name]"
        "[raw][ZoneIdContents]" => "[file][fork_contents]"

        "[raw][isDirectory]" => "[@metadata][isDirectory]"
      }
      remove_field => [ "raw" ]
    }

    # if there is no filesize, set it to zero
    if ![file][size] {
      mutate {
        add_field => { "file][size" => 0 }
      }
      # this is needed because add_field always adds a string?!
      mutate {
        convert => [
          "[file][size]", "integer"
        ]
      }
    }

    # construct file.path
    mutate {
      add_field => {
        "[file][path]" => "%{[file][directory]}/%{[file][name]}"
      }
    }

    # override file.extension and add fork_name for ADS entries
    if [kape][mft][isads] == "true" {
      mutate {
        remove_field => [ "[file][extension]", "[file][fork_name]" ]
      }
      grok {
        match => [ "[file][name]", "%{GREEDYDATA}\.%{DATA:[file][extension]}:%{DATA:[file][fork_name]}$" ]
      }
    } else {
      # remove leading dot from file.extension
      if [file][extension] {
        mutate {
          gsub => [ "[file][extension]", "^.", "" ]
        }
      }
    }

    # use the stdinfo LastModified time for @timestamp, if present
    # otherwise, use created (e.g. with USN Journal records)
    if [file][stdinfo][mtime] {
      date {
        match => [ "[file][stdinfo][mtime]", "ISO8601" ]
      }
    } else {
      date {
        match => [ "[file][stdinfo][created]", "ISO8601" ]
      }
    }

    # convert all stdinfo timestamps to date/time types
    date {
      match => [ "[file][stdinfo][ctime]", "ISO8601" ]
      target => "[file][stdinfo][ctime]"
    }
    date {
      match => [ "[file][stdinfo][mtime]", "ISO8601" ]
      target => "[file][stdinfo][mtime]"
    }
    date {
      match => [ "[file][stdinfo][accessed]", "ISO8601" ]
      target => "[file][stdinfo][accessed]"
    }
    date {
      match => [ "[file][stdinfo][created]", "ISO8601" ]
      target => "[file][stdinfo][created]"
    }

    # convert all FILENAME timestamps to date/time types
    date {
      match => [ "[file][filename][ctime]", "ISO8601" ]
      target => "[file][filename][ctime]"
    }
    date {
      match => [ "[file][filename][mtime]", "ISO8601" ]
      target => "[file][filename][mtime]"
    }
    date {
      match => [ "[file][filename][accessed]", "ISO8601" ]
      target => "[file][filename][accessed]"
    }
    date {
      match => [ "[file][filename][created]", "ISO8601" ]
      target => "[file][filename][created]"
    }

    # convert SiFlags to array of atrributes
    if [file][attributes] {
      ruby {
        path => "/usr/local/sof-elk/supporting-scripts/ntfs_flags_to_array.rb"
        script_params => { "source_field" => "[file][attributes]", "source_type" => "int" }
      }
    }

    # if this is a directory, set values accordingly; otherwise set file status
    if [@metadata][isDirectory] == "true" {
      mutate {
        add_field => {
          "[file][attributes]" => "directory"
          "[file][type]" => "dir"
        }
      }
    } else {
      mutate {
        add_field => {
          "[file][type]" => "file"
        }
      }
    }
  }
}
