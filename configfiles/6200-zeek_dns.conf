# SOF-ELKÂ® Configuration File
# (C)2023 Lewes Technology Consulting, LLC
#
# This file contains processing steps for Zeek's DNS logs, normalizing them to existing mapppings for other DNS records
# Some portions orginally contributed by Justin Henderson

# Reference: https://docs.zeek.org/en/master/scripts/base/protocols/dns/main.zeek.html#type-DNS::Info

filter {
  if [type] == "zeek_dns" and "zeek_json" in [tags] {
    mutate {
      rename => {
        "[raw][uid]" => "[zeek][session_id]"
        "[raw][id.orig_h]" => "[source][ip]"
        "[raw][id.orig_p]" => "[source][port]"
        "[raw][id.resp_h]" => "[destination][ip]"
        "[raw][id.resp_p]" => "[destination][port]"
        "[raw][proto]" => "[network][transport]"
        "[raw][query]" => "[dns][question][name]"
        "[raw][qtype_name]" => "[dns][question][type]"
        "[raw][answers]" => "[dns][answers][data]"
        "[raw][TTLs]" => "[dns][answers][ttl]"
        "[raw][rcode_name]" => "[dns][response][code]"
        "[raw][trans_id]" => "[dns][id]"
        "[raw][rtt]" => "rtt"
        "[raw][Z]" => "[dnssec_z]"
        "[raw][rejected]" => "[dns_flags][rejected]"
      }
    }

    if [raw][qclass_name] {
      translate {
        dictionary_path => "/usr/local/sof-elk/lib/dictionaries/zeek_dns_class2classabbrev.yaml"
        source => "[raw][qclass_name]"
        target => "[dns][question][class]"
      }
    }

    # populate the @timestamp field with the ts value
    date {
      match => [ "[raw][ts]", "UNIX" ]
    }
    translate {
      dictionary_path => "/usr/local/sof-elk/lib/dictionaries/ip_proto_zeek2int.yaml"
      source => "[network][transport]"
      target => "[network][iana_number]"
    }

    if [dns][answers][data] and [dns][question][type] != "CNAME" {
      grok {
        match => [ "[dns][answers][data]", "^%{IP:answer.ip}$" ]
      }
    }

    if [source][ip] and [dns][question][name] and [dns][answers][data] {
      mutate {
        replace => { "message" => "DNS: %{[source][ip]} (%{[dns][question][name]} -> %{[dns][answers][data]})" }
      }
    } else if [source][ip] and [query] {
      mutate {
        replace => { "message" => "DNS: %{[source][ip]} (%{[dns][question][name]} -> No response)"}
      }
    }

    if [raw][AA] { mutate { merge { "[dns][header][flags]" => "[raw][AA]" } } }
    if [raw][TC] { mutate { merge { "[dns][header][flags]" => "[raw][TC]" } } }
    if [raw][RD] { mutate { merge { "[dns][header][flags]" => "[raw][RD]" } } }
    if [raw][RA] { mutate { merge { "[dns][header][flags]" => "[raw][RA]" } } }
    if [raw][AD] { mutate { merge { "[dns][header][flags]" => "[raw][AD]" } } }
    if [raw][CD] { mutate { merge { "[dns][header][flags]" => "[raw][CD]" } } }
    if [raw][DO] { mutate { merge { "[dns][header][flags]" => "[raw][DO]" } } }

    mutate {
      convert => {
        "[network][iana_number]" => "integer"
      }
      remove_field => "raw"
    }
  }
}
