# SOF-ELKÂ® Configuration File
# (C)2023 Lewes Technology Consulting, LLC
#
# This file contains processing steps for Zeek's connection logs, normalizing them to existing netflow mapppings
# Some portions orginally contributed by Justin Henderson

# Reference: https://docs.zeek.org/en/master/scripts/base/protocols/conn/main.zeek.html#type-Conn::Info

filter {
  if [type] == "zeek_conn"  and "zeek_json" in [tags] {
    mutate {
      rename => {
        "[raw][uid]" => "[zeek][session_id]"
        "[raw][id.orig_h]" => "[source][ip]"
        "[raw][id.orig_p]" => "[source][port]"
        "[raw][id.resp_h]" => "[destination][ip]"
        "[raw][id.resp_p]" => "[destination][port]"
        "[raw][proto]" => "[network][transport]"
        "[raw][service]" => "zeek_service"
        "[raw][duration]" => "flow_duration"
        "[raw][orig_bytes]" => "[source][bytes]"
        "[raw][resp_bytes]" => "[destination][bytes]"
        "[raw][conn_state]" => "zeek_conn_state"
        "[raw][local_orig]" => "zeek_local_source"
        "[raw][local_resp]" => "zeek_local_destination"
        "[raw][missed_bytes]" => "missed_bytes"
        "[raw][history]" => "zeek_history"
        "[raw][orig_pkts]" => "[source][packets]"
        "[raw][orig_ip_bytes]" => "out_ip_bytes"
        "[raw][resp_pkts]" => "[destination][packets]"
        "[raw][resp_ip_bytes]" => "in_ip_bytes"
        "[raw][tunnel_parents]" => "zeek_tunnel_parents"
        "[raw][community_id]" => "[network][community_id]"
        "[raw][orig_l2_addr]" => "out_src_mac"
        "[raw][resp_l2_addr]" => "in_src_mac"
        "[raw][vlan]" => "destination_vlan"
      }

      # add fields needed for data consistency with other netflow sources
      add_field => {
        "[netflow][exporter][address]" => "0.0.0.0"
        "[netflow][delta_flow_count]" => "1"
      }
    }
    # populate additional fields or modify as needed to match flow sources
    if ![network][missed_bytes] {
      mutate {
        add_field => { "[network][missed_bytes]" => "0" }
      }
    }
    if ![destination][bytes] {
      mutate {
        add_field => { "[destination][bytes]" => "0" }
      }
    }
    if ![destination][packets] {
      mutate {
        add_field => { "[destination][packets]" => "0" }
      }
    }
    if ![source][bytes] {
      mutate {
        add_field => { "[source][bytes]" => "0" }
      }
    }
    if ![source][packets] {
      mutate {
        add_field => { "[source][packets]" => "0" }
      }
    }

    # populate the @timestamp field with the ts value
    date {
      match => [ "[raw][ts]", "UNIX" ]
    }

    # if there is no duration, it's zero so the start and end times are the same as @timestamp
    # use "0.0" to force this into a float later
    if ![flow_duration] {
      mutate {
        add_field => {
          "flow_duration" => "0.0"
          "flow_start" => "%{@timestamp}"
          "flow_end" => "%{@timestamp}"
        }
      }

    # otherwise, calculate the end time from @timestamp+flow_duration and then set start time to @timestamp
    } else {
      ruby {
        init => "require 'date'"
        code => "event.set('flow_end', Time.at(event.get('@timestamp').to_f + event.get('flow_duration').to_f))"
        add_field => {
          "flow_start" => "%{@timestamp}"
        }
        add_tag => [ "calculated_flow_end" ]
      }
    }

    translate {
      dictionary_path => "/usr/local/sof-elk/lib/dictionaries/ip_proto_zeek2int.yaml"
      source => "[network][transport]"
      target => "[network][iana_number]"
    }

    # note that we don't have native tcp flag info, but this can generally be derived from the "zeek_history" field
    # at some point in the future, this may be suitable for a ruby{} or translate{} conversion but that will take some research and validation

    if [zeek_conn_state] {
      translate {
        dictionary_path => "/usr/local/sof-elk/lib/dictionaries/zeek_connection_state2desc.yaml"
        source => "[zeek_conn_state]"
        target => "[zeek_conn_state_description]"
      }
    }

    mutate {
      convert => {
        "[network][iana_number]" => "integer"
        "[destination][bytes]" => "integer"
        "in_ip_bytes" => "integer"
        "[source][bytes]" => "integer"
        "out_ip_bytes" => "integer"
        "[netflow][delta_flow_count]" => "integer"
        "[destination][packets]" => "integer"
        "[source][packets]" => "integer"
        "[network][missed_bytes]" => "integer"
      }
      remove_field => "raw"
    }
  }
}
